# Copyright 2020 Tier IV, Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os

from ament_index_python.packages import get_package_share_directory
import launch
from launch.actions import DeclareLaunchArgument
from launch.actions import OpaqueFunction
from launch.actions import SetLaunchConfiguration
from launch.conditions import IfCondition
from launch.conditions import UnlessCondition
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import LoadComposableNodes
from launch_ros.descriptions import ComposableNode
from launch_ros.parameter_descriptions import ParameterFile


def launch_setup(context, *args, **kwargs):
    # Get sensor kit name for package paths
    sensor_kit_launch_share_dir = get_package_share_directory("{{ sensor_kit_name }}_launch")
    
    # concatenate node parameters
    concatenate_and_time_sync_node_param = ParameterFile(
        param_file=LaunchConfiguration("concatenate_and_time_sync_node_param_path").perform(
            context
        ),
        allow_substs=True,
    )

{%- if 'lidar' in sensors and sensors.lidar | length > 0 %}
    # Define input topics for concatenation based on configured LiDARs
    input_topics = [
{%- for lidar in sensors.lidar %}
        "/sensing/lidar/{{ lidar.name.replace('velodyne_', '').replace('lidar_', '') }}/pointcloud_raw",
{%- endfor %}
    ]
    
    # Determine if concatenation is needed
    use_concat = {{ 'true' if sensors.lidar | length > 1 else 'false' }}
{%- else %}
    input_topics = []
    use_concat = False
{%- endif %}

    # Components list
    components = []

    # Concatenate component for multiple LiDARs
    if use_concat and LaunchConfiguration("use_concat_filter").perform(context) == "true":
        concat_component = ComposableNode(
            package="autoware_pointcloud_preprocessor",
            plugin="autoware::pointcloud_preprocessor::PointCloudConcatenateDataSynchronizerComponent",
            name="concatenate_data",
            remappings=[
                ("~/input/twist", "/sensing/vehicle_velocity_converter/twist_with_covariance"),
                ("output", "concatenated/pointcloud"),
            ] + [
                (f"input{i}", topic) for i, topic in enumerate(input_topics)
            ],
            parameters=[
                concatenate_and_time_sync_node_param,
                {
                    "input_topics": input_topics,
                    "output_frame": LaunchConfiguration("base_frame"),
                    "timeout_sec": 0.1,
                }
            ],
            extra_arguments=[{"use_intra_process_comms": LaunchConfiguration("use_intra_process")}],
        )
        components.append(concat_component)

{%- if 'lidar' in sensors %}
{%- for lidar in sensors.lidar %}
    # Preprocessing for {{ lidar.name }}
    {{ lidar.name }}_components = []
    
    # Ring outlier filter
    ring_outlier_filter_{{ loop.index }} = ComposableNode(
        package="autoware_pointcloud_preprocessor",
        plugin="autoware::pointcloud_preprocessor::RingOutlierFilterComponent",
        name="{{ lidar.name }}_ring_outlier_filter",
        remappings=[
            ("input", "/sensing/lidar/{{ lidar.name.replace('velodyne_', '').replace('lidar_', '') }}/pointcloud_raw"),
            ("output", "/sensing/lidar/{{ lidar.name.replace('velodyne_', '').replace('lidar_', '') }}/pointcloud_filtered"),
        ],
        parameters=[{
            "distance_ratio": 0.1,
            "object_length_threshold": 0.1,
            "num_points_threshold": 4,
{%- if lidar.channels is defined %}
            "max_rings_num": {{ lidar.channels }},
{%- endif %}
        }],
        extra_arguments=[{"use_intra_process_comms": LaunchConfiguration("use_intra_process")}],
    )
    {{ lidar.name }}_components.append(ring_outlier_filter_{{ loop.index }})
    
    # Distortion corrector
    distortion_corrector_{{ loop.index }} = ComposableNode(
        package="autoware_pointcloud_preprocessor",
        plugin="autoware::pointcloud_preprocessor::DistortionCorrectorComponent",
        name="{{ lidar.name }}_distortion_corrector",
        remappings=[
            ("~/input/twist", "/sensing/vehicle_velocity_converter/twist_with_covariance"),
            ("~/input/pointcloud", "/sensing/lidar/{{ lidar.name.replace('velodyne_', '').replace('lidar_', '') }}/pointcloud_filtered"),
            ("~/output/pointcloud", "/sensing/lidar/{{ lidar.name.replace('velodyne_', '').replace('lidar_', '') }}/pointcloud_corrected"),
        ],
        parameters=[{
            "base_frame": LaunchConfiguration("base_frame"),
            "use_imu": True,
        }],
        extra_arguments=[{"use_intra_process_comms": LaunchConfiguration("use_intra_process")}],
    )
    {{ lidar.name }}_components.append(distortion_corrector_{{ loop.index }})
    
    components.extend({{ lidar.name }}_components)
{%- endfor %}
{%- endif %}

    # Passthrough filter for single LiDAR or when concat is disabled
{%- if 'lidar' in sensors and sensors.lidar | length == 1 %}
    if not use_concat or LaunchConfiguration("use_concat_filter").perform(context) == "false":
        passthrough_component = ComposableNode(
            package="autoware_pointcloud_preprocessor",
            plugin="autoware::pointcloud_preprocessor::PassthroughFilterComponent",
            name="passthrough_filter",
            remappings=[
                ("input", "/sensing/lidar/{{ sensors.lidar[0].name.replace('velodyne_', '').replace('lidar_', '') }}/pointcloud_corrected"),
                ("output", "concatenated/pointcloud"),
            ],
            parameters=[{
                "output_frame": LaunchConfiguration("base_frame"),
            }],
            extra_arguments=[{"use_intra_process_comms": LaunchConfiguration("use_intra_process")}],
        )
        components.append(passthrough_component)
{%- endif %}

    # Load all components
    if components:
        loader = LoadComposableNodes(
            composable_node_descriptions=components,
            target_container=LaunchConfiguration("pointcloud_container_name"),
        )
        return [loader]
    else:
        return []


def generate_launch_description():
    launch_arguments = []

    def add_launch_arg(name: str, default_value=None):
        launch_arguments.append(DeclareLaunchArgument(name, default_value=default_value))

    sensor_kit_launch_share_dir = get_package_share_directory("{{ sensor_kit_name }}_launch")

    add_launch_arg("base_frame", "base_link")
    add_launch_arg("use_multithread", "False")
    add_launch_arg("use_intra_process", "False")
    add_launch_arg("use_concat_filter", "{{ 'True' if 'lidar' in sensors and sensors.lidar | length > 1 else 'False' }}")
    add_launch_arg("pointcloud_container_name", "pointcloud_container")
    add_launch_arg(
        "concatenate_and_time_sync_node_param_path",
        os.path.join(
            sensor_kit_launch_share_dir,
            "config",
            "concatenate_and_time_sync_node.param.yaml",
        ),
    )

    set_container_executable = SetLaunchConfiguration(
        "container_executable",
        "component_container",
        condition=UnlessCondition(LaunchConfiguration("use_multithread")),
    )

    set_container_mt_executable = SetLaunchConfiguration(
        "container_executable",
        "component_container_mt",
        condition=IfCondition(LaunchConfiguration("use_multithread")),
    )

    return launch.LaunchDescription(
        launch_arguments
        + [set_container_executable, set_container_mt_executable]
        + [OpaqueFunction(function=launch_setup)]
    )